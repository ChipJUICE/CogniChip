{
  "id": "584d3198-9a2c-4bf0-b325-02f7f85a1d23",
  "status": "SUBMIT",
  "name": "584D3198",
  "fileRefs": [
    {
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/juicekadai/Desktop/cognichip/idle_predictor.sv",
        "external": "file:///Users/juicekadai/Desktop/cognichip/idle_predictor.sv",
        "path": "/Users/juicekadai/Desktop/cognichip/idle_predictor.sv",
        "scheme": "file"
      },
      "name": "idle_predictor.sv",
      "fileData": "// =============================================================================\n// Module: idle_predictor\n// Description: Low-power SoC peripheral idle prediction with adaptive thresholds\n// =============================================================================\n// Determines when peripherals can safely enter SLEEP state based on idle \n// duration and recent activity patterns. Uses lightweight arithmetic-based\n// adaptive thresholding with guaranteed latch-free synthesis.\n// =============================================================================\n\nmodule idle_predictor #(\n    parameter int N = 4,   // Number of peripherals\n    parameter int W = 16   // Counter/threshold width (bits)\n) (\n    // Clock and reset\n    input  logic                clk,\n    input  logic                rst_n,\n    \n    // Idle monitoring inputs\n    input  logic [N-1:0][W-1:0] idle_count,       // Per-peripheral idle cycle count\n    input  logic [N-1:0][W-1:0] idle_base_th,     // Base idle threshold (programmable)\n    input  logic [N-1:0]        recent_activity,  // Recent activity indicator\n    \n    // Adaptation control\n    input  logic [3:0]          alpha,            // Adaptation strength tuning\n    \n    // Sleep eligibility output\n    output logic [N-1:0]        sleep_eligible    // Asserted when sleep is safe\n);\n\n    // =========================================================================\n    // Internal signals - declared outside generate for proper scoping\n    // =========================================================================\n    \n    logic [N-1:0][W-1:0] adaptive_threshold;      // Computed adaptive threshold\n    logic [N-1:0]        sleep_eligible_comb;     // Combinational eligibility\n    \n    // =========================================================================\n    // Per-Peripheral Adaptive Threshold and Sleep Eligibility Logic\n    // =========================================================================\n    // Generate loop for each peripheral to compute:\n    //   adaptive_th = base_th + (recent_activity ? (base_th >> alpha) : 0)\n    //   sleep_eligible = (idle_count >= adaptive_th)\n    // =========================================================================\n    \n    generate\n        for (genvar i = 0; i < N; i++) begin : g_peripheral\n            \n            // Local signals for each peripheral (no latches)\n            logic [W-1:0]   adjustment;           // Threshold adjustment value\n            logic [W:0]     sum_extended;         // Extended for overflow detection\n            logic           overflow;             // Overflow flag\n            \n            // -----------------------------------------------------------------\n            // Adaptive Threshold Computation (Combinational)\n            // -----------------------------------------------------------------\n            // Formula: adaptive_th = base_th + (recent_activity ? adjustment : 0)\n            // With saturation at maximum value on overflow\n            // -----------------------------------------------------------------\n            \n            always_comb begin\n                // Default values to prevent latches\n                adjustment = '0;\n                sum_extended = '0;\n                overflow = 1'b0;\n                adaptive_threshold[i] = '0;\n                \n                // Compute adjustment based on recent activity\n                if (recent_activity[i]) begin\n                    adjustment = idle_base_th[i] >> alpha;\n                end else begin\n                    adjustment = '0;\n                end\n                \n                // Perform addition with overflow detection\n                sum_extended = {1'b0, idle_base_th[i]} + {1'b0, adjustment};\n                overflow = sum_extended[W];  // MSB indicates overflow\n                \n                // Apply saturation on overflow\n                if (overflow) begin\n                    adaptive_threshold[i] = {W{1'b1}};  // Saturate to max value\n                end else begin\n                    adaptive_threshold[i] = sum_extended[W-1:0];\n                end\n            end\n            \n            // -----------------------------------------------------------------\n            // Sleep Eligibility Comparison (Combinational)\n            // -----------------------------------------------------------------\n            // Assert when idle_count meets or exceeds adaptive threshold\n            // -----------------------------------------------------------------\n            \n            always_comb begin\n                // Default to prevent latches\n                sleep_eligible_comb[i] = 1'b0;\n                \n                // Compare idle count against adaptive threshold\n                sleep_eligible_comb[i] = (idle_count[i] >= adaptive_threshold[i]);\n            end\n            \n        end : g_peripheral\n    endgenerate\n    \n    // =========================================================================\n    // Output Registration (Sequential)\n    // =========================================================================\n    // Register outputs with synchronous reset for clean timing\n    // =========================================================================\n    \n    always_ff @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            sleep_eligible <= '0;\n        end else begin\n            sleep_eligible <= sleep_eligible_comb;\n        end\n    end\n\nendmodule : idle_predictor\n",
      "id": "f89b84c2-3626-413a-b718-0cd2f4f7b422",
      "type": "sv",
      "size": 4389,
      "stats": {
        "type": 1,
        "ctime": 1771272005402,
        "mtime": 1771272005403,
        "size": 4389
      }
    },
    {
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/juicekadai/Desktop/cognichip/tb_idle_predictor.sv",
        "external": "file:///Users/juicekadai/Desktop/cognichip/tb_idle_predictor.sv",
        "path": "/Users/juicekadai/Desktop/cognichip/tb_idle_predictor.sv",
        "scheme": "file"
      },
      "name": "tb_idle_predictor.sv",
      "fileData": "// =============================================================================\n// Testbench: tb_idle_predictor\n// Description: Self-checking testbench for idle_predictor RTL module\n// =============================================================================\n// Verifies adaptive idle threshold computation and sleep eligibility decisions\n// for low-power SoC peripheral controller.\n// =============================================================================\n\n`timescale 1ns/1ps\n\nmodule tb_idle_predictor;\n\n    // =========================================================================\n    // Parameters (matching DUT)\n    // =========================================================================\n    \n    localparam int N = 4;   // Number of peripherals\n    localparam int W = 16;  // Counter/threshold width\n    \n    // =========================================================================\n    // Clock and Reset\n    // =========================================================================\n    \n    logic clock;\n    logic reset;\n    \n    // =========================================================================\n    // DUT Interface Signals\n    // =========================================================================\n    \n    logic [N-1:0][W-1:0] idle_count;\n    logic [N-1:0][W-1:0] idle_base_th;\n    logic [N-1:0]        recent_activity;\n    logic [3:0]          alpha;\n    logic [N-1:0]        sleep_eligible;\n    \n    // =========================================================================\n    // Testbench Variables\n    // =========================================================================\n    \n    int test_count;\n    int pass_count;\n    int fail_count;\n    \n    // =========================================================================\n    // DUT Instantiation\n    // =========================================================================\n    \n    idle_predictor #(\n        .N(N),\n        .W(W)\n    ) dut (\n        .clk(clock),\n        .rst_n(reset),\n        .idle_count(idle_count),\n        .idle_base_th(idle_base_th),\n        .recent_activity(recent_activity),\n        .alpha(alpha),\n        .sleep_eligible(sleep_eligible)\n    );\n    \n    // =========================================================================\n    // Clock Generation (100MHz = 10ns period)\n    // =========================================================================\n    \n    initial begin\n        clock = 0;\n        forever #5 clock = ~clock;\n    end\n    \n    // =========================================================================\n    // Golden Reference Model\n    // =========================================================================\n    // Mirrors the RTL adaptive threshold computation exactly\n    // Formula: adaptive_th = base_th + (recent_activity ? (base_th >> alpha) : 0)\n    // =========================================================================\n    \n    function automatic logic [N-1:0] golden_model(\n        input logic [N-1:0][W-1:0] idle_cnt,\n        input logic [N-1:0][W-1:0] base_th,\n        input logic [N-1:0]        recent_act,\n        input logic [3:0]          alph\n    );\n        logic [N-1:0][W-1:0] adaptive_th;\n        logic [N-1:0]        expected_eligible;\n        logic [W-1:0]        adjustment;\n        logic [W:0]          sum_extended;\n        logic                overflow;\n        \n        for (int i = 0; i < N; i++) begin\n            // Compute adjustment based on recent activity\n            // Formula: adaptive_th = base_th + (recent_activity ? (base_th >> alpha) : 0)\n            if (recent_act[i]) begin\n                adjustment = base_th[i] >> alph;\n            end else begin\n                adjustment = '0;\n            end\n            \n            // Perform addition with overflow detection\n            sum_extended = {1'b0, base_th[i]} + {1'b0, adjustment};\n            overflow = sum_extended[W];\n            \n            // Apply saturation on overflow\n            if (overflow) begin\n                adaptive_th[i] = {W{1'b1}};  // Saturate to max value\n            end else begin\n                adaptive_th[i] = sum_extended[W-1:0];\n            end\n            \n            // Check eligibility\n            expected_eligible[i] = (idle_cnt[i] >= adaptive_th[i]);\n        end\n        \n        return expected_eligible;\n    endfunction\n    \n    // =========================================================================\n    // Checker Task\n    // =========================================================================\n    // Compares DUT output against golden model and reports results\n    // =========================================================================\n    \n    task automatic check_output(\n        input string test_name,\n        input int peripheral_id\n    );\n        logic [N-1:0] expected;\n        logic match;\n        \n        // Wait one cycle for registered output\n        @(posedge clock);\n        #1; // Small delta for signal stability\n        \n        expected = golden_model(idle_count, idle_base_th, recent_activity, alpha);\n        match = (sleep_eligible == expected);\n        \n        test_count++;\n        \n        if (match) begin\n            pass_count++;\n            $display(\"LOG: %0t : INFO : tb_idle_predictor : dut.sleep_eligible[%0d] : expected_value: %b actual_value: %b - PASS: %s\",\n                     $time, peripheral_id, expected[peripheral_id], sleep_eligible[peripheral_id], test_name);\n        end else begin\n            fail_count++;\n            $display(\"LOG: %0t : ERROR : tb_idle_predictor : dut.sleep_eligible : expected_value: %b actual_value: %b\",\n                     $time, expected, sleep_eligible);\n            $display(\"ERROR: Test '%s' FAILED\", test_name);\n            $display(\"  idle_count      = %p\", idle_count);\n            $display(\"  idle_base_th    = %p\", idle_base_th);\n            $display(\"  recent_activity = %b\", recent_activity);\n            $display(\"  alpha           = %0d\", alpha);\n            $display(\"  expected        = %b\", expected);\n            $display(\"  actual          = %b\", sleep_eligible);\n            $fatal(1, \"Mismatch detected - terminating simulation\");\n        end\n    endtask\n    \n    // =========================================================================\n    // Initialize Inputs Task\n    // =========================================================================\n    \n    task init_inputs();\n        idle_count = '0;\n        idle_base_th = '0;\n        recent_activity = '0;\n        alpha = '0;\n    endtask\n    \n    // =========================================================================\n    // Main Test Sequence\n    // =========================================================================\n    \n    initial begin\n        $display(\"TEST START\");\n        $display(\"=========================================================================\");\n        $display(\"Testbench: tb_idle_predictor\");\n        $display(\"DUT: idle_predictor (N=%0d, W=%0d)\", N, W);\n        $display(\"=========================================================================\");\n        \n        test_count = 0;\n        pass_count = 0;\n        fail_count = 0;\n        \n        // =====================================================================\n        // Reset Sequence - Robust Reset Test\n        // =====================================================================\n        $display(\"\\n[PHASE 1] Reset Test\");\n        $display(\"---------------------------------------------------------------------\");\n        $display(\"Applying reset with safe input values...\");\n        \n        // Drive all inputs to safe, known values during reset\n        // This ensures we don't assume uninitialized state behavior\n        for (int i = 0; i < N; i++) begin\n            idle_count[i] = '0;           // No idle time accumulated\n            idle_base_th[i] = '1;         // Maximum threshold value\n        end\n        recent_activity = '0;             // No recent activity\n        alpha = 4'h0;                     // Alpha = 0\n        \n        // Assert reset for 3 clock cycles\n        reset = 0;\n        repeat(3) @(posedge clock);\n        \n        // Deassert reset\n        reset = 1;\n        $display(\"Reset deasserted at time %0t\", $time);\n        \n        // Wait for registered output to update (1-2 clock cycles)\n        @(posedge clock);\n        @(posedge clock);\n        #1; // Small delta for signal stability\n        \n        // Check that all outputs are cleared after reset\n        // With idle_count=0 and idle_base_th=max, sleep_eligible should be 0\n        $display(\"Checking reset behavior:\");\n        $display(\"  idle_count      = %p (all zeros)\", idle_count);\n        $display(\"  idle_base_th    = %p (all max)\", idle_base_th);\n        $display(\"  recent_activity = %b (all zeros)\", recent_activity);\n        $display(\"  alpha           = %0d\", alpha);\n        $display(\"  sleep_eligible  = %b (checking for all zeros)\", sleep_eligible);\n        \n        if (sleep_eligible == '0) begin\n            $display(\"LOG: %0t : INFO : tb_idle_predictor : dut.sleep_eligible : expected_value: 0 actual_value: %b - PASS: Reset clears outputs\",\n                     $time, sleep_eligible);\n            pass_count++;\n            test_count++;\n        end else begin\n            $display(\"LOG: %0t : ERROR : tb_idle_predictor : dut.sleep_eligible : expected_value: 0 actual_value: %b\",\n                     $time, sleep_eligible);\n            fail_count++;\n            test_count++;\n            $fatal(1, \"Reset test failed - outputs not cleared\");\n        end\n        \n        // =====================================================================\n        // Directed Test Cases\n        // =====================================================================\n        $display(\"\\n[PHASE 2] Directed Test Cases\");\n        $display(\"---------------------------------------------------------------------\");\n        \n        // ---------------------------------------------------------------------\n        // Case A: Below Threshold\n        // ---------------------------------------------------------------------\n        $display(\"\\n--- Test Case A: Below Threshold ---\");\n        init_inputs();\n        idle_base_th[0] = 20;\n        idle_count[0] = 19;\n        recent_activity[0] = 0;\n        alpha = 2;\n        check_output(\"Case A: Below Threshold\", 0);\n        \n        // ---------------------------------------------------------------------\n        // Case B: At Threshold\n        // ---------------------------------------------------------------------\n        $display(\"\\n--- Test Case B: At Threshold ---\");\n        init_inputs();\n        idle_base_th[0] = 20;\n        idle_count[0] = 20;\n        recent_activity[0] = 0;\n        alpha = 2;\n        check_output(\"Case B: At Threshold\", 0);\n        \n        // ---------------------------------------------------------------------\n        // Case C: Recent Activity Increases Threshold\n        // ---------------------------------------------------------------------\n        $display(\"\\n--- Test Case C: Recent Activity Increases Threshold ---\");\n        init_inputs();\n        idle_base_th[0] = 20;\n        idle_count[0] = 24;  // Would pass base threshold\n        recent_activity[0] = 1;  // But recent activity increases threshold\n        alpha = 2;  // adaptive_th = 20 + (20>>2) = 20 + 5 = 25\n        // idle_count=24 < adaptive_th=25, so should NOT be eligible\n        check_output(\"Case C: Recent Activity Blocks Sleep\", 0);\n        \n        // ---------------------------------------------------------------------\n        // Case D: No Recent Activity (Threshold = Base)\n        // ---------------------------------------------------------------------\n        $display(\"\\n--- Test Case D: No Recent Activity (Threshold = Base) ---\");\n        init_inputs();\n        idle_base_th[0] = 20;\n        idle_count[0] = 20;  // Equal to base threshold\n        recent_activity[0] = 0;  // No activity: adaptive_th = base_th + 0 = 20\n        alpha = 2;  // adaptive_th = 20 + 0 = 20\n        // idle_count=20 >= adaptive_th=20, so SHOULD be eligible\n        check_output(\"Case D: No Activity Keeps Base Threshold\", 0);\n        \n        // ---------------------------------------------------------------------\n        // Multi-Peripheral Test\n        // ---------------------------------------------------------------------\n        $display(\"\\n--- Test Case: Multi-Peripheral ---\");\n        init_inputs();\n        // Peripheral 0: eligible\n        idle_base_th[0] = 10;\n        idle_count[0] = 15;\n        recent_activity[0] = 0;\n        \n        // Peripheral 1: not eligible (below threshold)\n        idle_base_th[1] = 30;\n        idle_count[1] = 20;\n        recent_activity[1] = 0;\n        \n        // Peripheral 2: eligible (at threshold)\n        idle_base_th[2] = 25;\n        idle_count[2] = 25;\n        recent_activity[2] = 0;\n        \n        // Peripheral 3: not eligible (recent activity)\n        idle_base_th[3] = 10;\n        idle_count[3] = 12;\n        recent_activity[3] = 1;  // adaptive_th will be > 12\n        \n        alpha = 1;\n        check_output(\"Multi-Peripheral Test\", 0);\n        \n        // =====================================================================\n        // Random Testing\n        // =====================================================================\n        $display(\"\\n[PHASE 3] Random Testing (200+ trials)\");\n        $display(\"---------------------------------------------------------------------\");\n        \n        for (int trial = 0; trial < 200; trial++) begin\n            init_inputs();\n            \n            // Randomize inputs\n            for (int i = 0; i < N; i++) begin\n                idle_count[i] = $urandom_range(0, (1 << W) - 1);\n                idle_base_th[i] = $urandom_range(1, (1 << (W-1)) - 1);\n                recent_activity[i] = $urandom_range(0, 1);\n            end\n            alpha = $urandom_range(0, 15);\n            \n            check_output($sformatf(\"Random Trial %0d\", trial), 0);\n            \n            if ((trial + 1) % 50 == 0) begin\n                $display(\"  Completed %0d/%0d random trials...\", trial + 1, 200);\n            end\n        end\n        \n        // =====================================================================\n        // Edge Cases\n        // =====================================================================\n        $display(\"\\n[PHASE 4] Edge Cases\");\n        $display(\"---------------------------------------------------------------------\");\n        \n        // Edge case: alpha = 0 (maximum adaptation)\n        $display(\"\\n--- Edge Case: Alpha = 0 (Max Adaptation) ---\");\n        init_inputs();\n        idle_base_th[0] = 100;\n        idle_count[0] = 150;\n        recent_activity[0] = 1;\n        alpha = 0;  // adaptive_th = 100 + (100>>0) = 200\n        check_output(\"Alpha=0 Max Adaptation\", 0);\n        \n        // Edge case: alpha = 15 (minimum adaptation)\n        $display(\"\\n--- Edge Case: Alpha = 15 (Min Adaptation) ---\");\n        init_inputs();\n        idle_base_th[0] = 100;\n        idle_count[0] = 100;\n        recent_activity[0] = 1;\n        alpha = 15;  // adaptive_th = 100 + (100>>15) = ~100\n        check_output(\"Alpha=15 Min Adaptation\", 0);\n        \n        // Edge case: zero base threshold\n        $display(\"\\n--- Edge Case: Zero Base Threshold ---\");\n        init_inputs();\n        idle_base_th[0] = 0;\n        idle_count[0] = 0;\n        recent_activity[0] = 0;\n        alpha = 2;\n        check_output(\"Zero Base Threshold\", 0);\n        \n        // Edge case: maximum values\n        $display(\"\\n--- Edge Case: Maximum Values ---\");\n        init_inputs();\n        idle_base_th[0] = (1 << W) - 1;\n        idle_count[0] = (1 << W) - 1;\n        recent_activity[0] = 1;\n        alpha = 1;\n        check_output(\"Maximum Values\", 0);\n        \n        // =====================================================================\n        // Test Summary\n        // =====================================================================\n        $display(\"\\n=========================================================================\");\n        $display(\"TEST SUMMARY\");\n        $display(\"=========================================================================\");\n        $display(\"Total Tests:  %0d\", test_count);\n        $display(\"Passed:       %0d\", pass_count);\n        $display(\"Failed:       %0d\", fail_count);\n        $display(\"=========================================================================\");\n        \n        if (fail_count == 0) begin\n            $display(\"TEST PASSED\");\n        end else begin\n            $display(\"TEST FAILED\");\n            $error(\"Simulation completed with %0d failures\", fail_count);\n        end\n        \n        $finish;\n    end\n    \n    // =========================================================================\n    // Timeout Watchdog\n    // =========================================================================\n    \n    initial begin\n        #100000; // 100us timeout\n        $display(\"ERROR: Simulation timeout - test did not complete\");\n        $fatal(1, \"Timeout watchdog triggered\");\n    end\n    \n    // =========================================================================\n    // Waveform Dump\n    // =========================================================================\n    \n    initial begin\n        $dumpfile(\"dumpfile.fst\");\n        $dumpvars(0);\n    end\n\nendmodule : tb_idle_predictor\n",
      "id": "78aac038-b970-492e-a46a-a5e0d917fed7",
      "type": "sv",
      "size": 15844,
      "stats": {
        "type": 1,
        "ctime": 1771272204617,
        "mtime": 1771272204617,
        "size": 15844
      }
    },
    {
      "uri": {
        "$mid": 1,
        "fsPath": "/Users/juicekadai/Desktop/cognichip/DEPS.yml",
        "external": "file:///Users/juicekadai/Desktop/cognichip/DEPS.yml",
        "path": "/Users/juicekadai/Desktop/cognichip/DEPS.yml",
        "scheme": "file"
      },
      "name": "DEPS.yml",
      "fileData": "tb_idle_predictor:\n  deps:\n    - idle_predictor.sv\n    - tb_idle_predictor.sv\n",
      "id": "a34db7ff-6e41-4c03-9cf7-8a0598f63349",
      "type": "yml",
      "size": 37,
      "stats": {
        "type": 1,
        "ctime": 1771272247119,
        "mtime": 1771272247120,
        "size": 37
      }
    }
  ],
  "jobs": {
    "jobIds": []
  },
  "callbackData": null,
  "target": "tb_idle_predictor",
  "waves": true,
  "openCos": ""
}